import mongoose, { Document, Schema } from 'mongoose';
import { isValidUrl } from '../middleware/validator.ts';

// Define an interface for the document
export interface DeploymentVersion {
    versionTag: string;
    customUrl?: string;
    encryptedApiKey?: string;
    status: 'active' | 'deprecated';
    createdAt: Date;
}

export interface IGymAgent extends Document {
    pool_id: mongoose.Types.ObjectId;
    name: string;
    ticker: string;
    description: string;
    logoUrl?: string;
    tokenomics: {
        supply: number;
        minLiquiditySol: number;
        gatedPercentage: number;
        decimals: number;
    };
    legal: {
        autoGeneratedTerms: boolean;
        termsUrl?: string;
    };
    deployment: {
        status: 'DRAFT' | 'PENDING_TOKEN_SIGNATURE' | 'TOKEN_CREATED' | 'PENDING_POOL_SIGNATURE' | 'DEPLOYED' | 'DEACTIVATED' | 'FAILED' | 'ARCHIVED';
        lastError?: string;
        consecutiveFailures?: number;
        activeVersionTag?: string;
        versions: DeploymentVersion[];
        pendingTransaction?: {
            idempotencyKey: string;
            type: 'TOKEN_CREATION' | 'POOL_CREATION';
            status: 'PENDING' | 'PROCESSING' | 'SUBMITTED';
            txHash?: string;
            details: any;
        };
        lastAttemptedAt?: Date; // For atomic locking during tx submission
        transitionLock?: Date; // Distributed lock for state transitions
        transitionLockBy?: string; // Process ID that holds the lock
    };
    blockchain: {
        tokenAddress?: string;
        tokenCreationDetails?: {
            txHash: string;
            timestamp: number; // Unix timestamp from Solana blockTime
            slot: number; // Solana block slot
        };
        poolAddress?: string;
        poolCreationDetails?: {
            txHash: string;
            timestamp: number; // Unix timestamp from Solana blockTime
            slot: number; // Solana block slot
        };
    };
    auditLog: {
        timestamp: Date;
        user: string;
        action: string;
        details: mongoose.Schema.Types.Mixed;
    }[];
}

// Define the schema
const GymAgentSchema = new Schema<IGymAgent>(
    {
        /**
         * A mandatory reference to the TrainingPool. This establishes the core link
         * between the training environment and the resulting agent.
         * It should be unique to enforce a one-agent-per-pool rule.
         */
        pool_id: {
            type: Schema.Types.ObjectId,
            ref: 'TrainingPool',
            required: true,
        },

        /**
         * General public information about the agent.
         */
        name: { type: String, required: true }, // The public display name of the agent.
        ticker: {
            type: String,
            required: true,
            uppercase: true,
            minlength: 3,
            maxlength: 10,
            match: /^[A-Z0-9]+$/, // Ensures the ticker contains only uppercase letters and numbers.
        }, // The token ticker, e.g., "AGENTX".
        description: { type: String, required: true }, // A detailed description of the agent's purpose and capabilities.
        logoUrl: {
            type: String,
            required: false,
            validate: {
                validator: function (v: string) {
                    return isValidUrl(v) && /^https?:\/\/.+\.(jpg|jpeg|png|gif|svg)$/i.test(v);
                },
                message: (props: { value: string }) => `${props.value} is not a valid image URL.`
            }
        }, // URL for the agent's logo. For V1, the user is responsible for hosting the image at an external, publicly accessible URL.

        /**
         * Defines the tokenomics for the agent's associated SPL token.
         */
        tokenomics: {
            supply: {
                type: Number,
                required: true,
                min: 1000, // A minimum supply to ensure viability.
                max: 1_000_000_000_000, // A maximum supply to prevent absurd values.
            }, // The total initial supply of the token.
            minLiquiditySol: { type: Number, required: true }, // The minimum amount of SOL to pair with the agent's token in the Raydium liquidity pool.
            gatedPercentage: { type: Number, required: false, default: 0, min: 0, max: 50 }, // The percentage of the supply to be token-gated.
            decimals: { type: Number, required: true, default: 9, min: 0, max: 12 } // The number of decimal places for the token.
        },

        /**
         * Handles legal aspects, primarily the Terms and Conditions.
         */
        legal: {
            autoGeneratedTerms: { type: Boolean, default: true }, // Whether the T&Cs are auto-generated by the platform.
            termsUrl: {
                type: String,
                required: false,
                validate: {
                    validator: isValidUrl,
                    message: (props: { value: string }) => `${props.value} is not a valid URL.`
                }
            } // A link to the final T&Cs document.
        },

        /**
         * Contains configuration and status related to the agent's deployment and its versions.
         */
        deployment: {
            status: {
                type: String,
                enum: ['DRAFT', 'PENDING_TOKEN_SIGNATURE', 'TOKEN_CREATED', 'PENDING_POOL_SIGNATURE', 'DEPLOYED', 'DEACTIVATED', 'FAILED', 'ARCHIVED'],
                default: 'DRAFT'
            },
            lastError: { type: String, required: false },
            consecutiveFailures: { type: Number, default: 0 },
            activeVersionTag: { type: String, required: false },
            versions: [
                new Schema({
                    versionTag: { type: String, required: true },
                    customUrl: {
                        type: String,
                        validate: {
                            validator: isValidUrl,
                            message: (props: { value: string }) => `${props.value} is not a valid URL.`
                        }
                    },
                    encryptedApiKey: { type: String },
                    status: { type: String, enum: ['active', 'deprecated'], required: true },
                    createdAt: { type: Date, default: Date.now }
                }, { _id: false })
            ],
            pendingTransaction: {
                idempotencyKey: { type: String },
                type: { type: String, enum: ['TOKEN_CREATION', 'POOL_CREATION'] },
                status: { type: String, enum: ['PENDING', 'PROCESSING', 'SUBMITTED'] },
                txHash: { type: String },
                details: { type: Schema.Types.Mixed },
            },
            lastAttemptedAt: { type: Date },
            transitionLock: { type: Date }, // Distributed lock for state transitions
            transitionLockBy: { type: String } // Process ID that holds the lock
        },

        /**
         * Stores all on-chain information related to the agent's token and liquidity pool.
         * This data provides a permanent, auditable record of the deployment events.
         */
        blockchain: {
            type: {
                tokenAddress: { type: String, required: false }, // The address of the created SPL token.
                tokenCreationDetails: {
                    type: {
                        txHash: { type: String, required: true },
                        timestamp: { type: Number, required: true }, // The on-chain blockTime (Unix timestamp)
                        slot: { type: Number, required: true }, // The Solana slot in which the transaction was confirmed
                    },
                    required: false
                }, // Details of the token creation transaction.
                poolAddress: { type: String, required: false }, // The ID of the created Raydium liquidity pool.
                poolCreationDetails: {
                    type: {
                        txHash: { type: String, required: true },
                        timestamp: { type: Number, required: true },
                        slot: { type: Number, required: true },
                    },
                    required: false
                }, // Details of the pool creation transaction.
            },
            default: {} // Ensure the blockchain object is initialized
        },

        /**
         * A log of all changes made to the agent document for audit purposes.
         */
        auditLog: [{
            timestamp: { type: Date, default: Date.now },
            user: { type: String, required: true }, // Wallet address of the user who performed the action
            action: { type: String, required: true }, // e.g., "CREATE", "UPDATE", "ARCHIVE"
            details: { type: Schema.Types.Mixed } // e.g., { changedFields: ['description'] }
        }]
    },
    {
        collection: 'gym_agents',
        timestamps: true,
    },
);

// Define indexes for performance
GymAgentSchema.index({ pool_id: 1 }, { unique: true });
GymAgentSchema.index({ 'deployment.status': 1 });
GymAgentSchema.index({ name: 'text', description: 'text' });
GymAgentSchema.index({ "auditLog.timestamp": -1 });

// Additional indexes for performance optimization
GymAgentSchema.index({ 'blockchain.tokenAddress': 1 }); // For token lookups
GymAgentSchema.index({ 'blockchain.poolAddress': 1 }); // For pool lookups
GymAgentSchema.index({ 'deployment.pendingTransaction.idempotencyKey': 1 }); // For transaction idempotency
GymAgentSchema.index({ 'deployment.pendingTransaction.status': 1 }); // For pending transaction queries
GymAgentSchema.index({ 'deployment.activeVersionTag': 1 }); // For active version lookups
GymAgentSchema.index({ 'deployment.consecutiveFailures': 1 }); // For failure monitoring
GymAgentSchema.index({ 'deployment.transitionLock': 1 }, { expireAfterSeconds: 3600 }); // For distributed locking with TTL
GymAgentSchema.index({ createdAt: -1 }); // For sorting by creation date
GymAgentSchema.index({ 'deployment.status': 1, createdAt: -1 }); // Compound index for status + date queries

export const GymAgentModel = mongoose.model<IGymAgent>('GymAgent', GymAgentSchema); 